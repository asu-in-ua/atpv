[<- До підрозділу](README.md)		[Коментувати](#feedback)

# Основи розгортання сервісів у Docker: практична частина

**Тривалість**: 4 акад. год (2 пари)

**Мета:**  Навчитися запускати та керувати контейнерами Docker на прикладі двох сервісів: MariaDB (БД) та Adminer (веб-адмінка), використовуючи мережу і томи.

## Лабораторна установка для проведення лабораторної роботи у віртуальному середовищі.

Апаратне забезпечення, матеріали та інструменти для проведення віртуальної лабораторної роботи.

- ПК 

Програмне забезпечення, що використане у віртуальній лабораторній роботі.

1. docker
1. portainer

## Загальна постановка задачі

Цілі роботи: 

- сформувати розуміння різниці між Docker-образом і контейнером;
- набути навичок запуску, зупинки та перезапуску контейнерів, перегляду журналів;
- набути навичок відображення портів і використання змінних середовища;
- зрозуміти призначення Docker-томів і принцип збереження даних незалежно від контейнера;
- зрозуміти роль Docker-мереж для ізоляції та взаємодії контейнерів;
- навчитися створювати простий Docker-образ за допомогою Dockerfile;
- набути навичок опису і запуску багатосервісного середовища за допомогою Docker Compose;
- ознайомитися з Portainer як веб-інтерфейсом для огляду та керування Docker-середовищем.

## Пререквізити

- повинна бути встановлена віртуальна машина з Debian, порядок встановлення за [посиланням](../vbox/labdebian.md)

## Послідовність виконання роботи

## Частина 1. Docker

### 1. Встановлення Docker

- [ ] Запустіть віртуальну машину з Debian
- [ ] Якщо хостова машина з Windows то рекомендується працювати через Putty, який дає можливість копіювати та вставляти команди, підключіться до системи VM  

- [ ] Увійдіть у систему під користувачем з правами адміністратора
- [ ] Оновіть список пакетів операційної системи

```bash
sudo apt update
```

- [ ] Встановіть службові пакети, необхідні для безпечного додавання офіційного репозиторію Docker і подальшого коректного встановлення Docker Engine через пакетний менеджер Debian.

```bash
sudo apt install -y ca-certificates curl gnupg lsb-release
```

- [ ] Цей крок додає офіційний GPG-ключ Docker, який використовується системою пакетів Debian для перевірки автентичності та цілісності пакетів, що завантажуються з репозиторію Docker.

```bash
sudo mkdir -p /etc/apt/keyrings
curl -fsSL https://download.docker.com/linux/debian/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg
```

- [ ] Цей крок додає офіційний репозиторій Docker до системи керування пакетами Debian, що дозволяє встановлювати і оновлювати Docker Engine з перевіреного джерела та отримувати актуальні версії програмного забезпечення.

```bash
echo \
"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] \
https://download.docker.com/linux/debian $(lsb_release -cs) stable" | \
sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
```

- [ ] Оновіть список пакетів з урахуванням нового репозиторію:

```bash
sudo apt update
```

- [ ] Встановіть Docker Engine:

```bash
sudo apt install -y docker-ce docker-ce-cli containerd.io
```

- [ ] Перевірте встановлення Docker:

```bash
docker version
```

Має вивести щось на кшталт:

```bash
Client: Docker Engine - Community
 Version:           29.1.3
 API version:       1.52
 Go version:        go1.25.5
 Git commit:        f52814d
 Built:             Fri Dec 12 14:49:42 2025
 OS/Arch:           linux/amd64
 Context:           default
permission denied while trying to connect to the docker API at unix:///var/run/docker.sock
```

- [ ] Переконайтесь, що служба Docker запущена:

```shell
sudo systemctl status docker
```

- [ ] Має вивести щось на кшталт

```bash
● docker.service - Docker Application Container Engine
     Loaded: loaded (/usr/lib/systemd/system/docker.service; enabled; preset: enabled)
     Active: active (running) since Tue 2025-12-30 10:31:44 UTC; 44s ago
 Invocation: 3cf1c0a5634d411498f2c0fcf6248d17
TriggeredBy: ● docker.socket
       Docs: https://docs.docker.com
   Main PID: 1556 (dockerd)
      Tasks: 9
     Memory: 26.1M (peak: 29.6M)
        CPU: 257ms
     CGroup: /system.slice/docker.service
             └─1556 /usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock

```

- [ ] Додайте користувача до групи `docker`. Цей крок потрібен, коли необхідно запускати команди Docker без `sudo`, оскільки додавання користувача до групи `docker` надає йому відповідні права доступу до Docker Engine; зазвичай це роблять у навчальних і робочих середовищах для зручності, але не є обов’язковим з точки зору працездатності Docker.

```bash
sudo usermod -aG docker $USER
```

### 2. Завантаження образу та запуск контейнера MariaDB

На цьому етапі лабораторної роботи перехід у робочий каталог не потрібен, оскільки використовується лише запуск готового Docker-образу без локальних файлів проєкту.

- [ ] Завантажте офіційний Docker-образ MariaDB:

```bash
docker pull mariadb
```


Ця команда завантажує образ MariaDB в локальний репозиторій з Docker Hub. Він буде використаний як шаблон для створення контейнера системи керування базою даних. Після виконання команди `docker pull` образ зберігається у внутрішньому сховищі Docker Engine на хості, а не в поточному каталозі користувача. Docker керує цим сховищем самостійно, типово воно розташоване в каталозі `/var/lib/docker`. Користувач не працює з цими файлами напряму і взаємодіє з образами лише через команди Docker, незалежно від того, з якої папки вони виконуються.

- [ ] Переконайтесь, що образ завантажений:

```bash
docker images
```

У списку образів повинен бути присутній образ `mariadb`.

- [ ] Запустіть контейнер MariaDB з мінімальними параметрами:

```bash
docker run -d \
  --name mariadb \
  -e MARIADB_ROOT_PASSWORD=secret \
  mariadb
```

де:

- `-d` — запуск контейнера у фоновому режимі;
- `--name mariadb` — задання імені контейнера для зручної ідентифікації та подальшого керування;
- `-e MARIADB_ROOT_PASSWORD=secret` — передача змінної середовища, яка задає пароль адміністратора (root) бази даних, тобто пароль `secret`;
- `mariadb` — назва Docker-образу, з якого створюється контейнер.

Змінна середовища — це параметр у форматі `ІМ’Я=ЗНАЧЕННЯ`, який передається процесу під час його запуску і використовується програмою для початкового налаштування. Змінні середовища в Docker використовуються для параметризації контейнерів під час запуску і дозволяють налаштовувати поведінку сервісу без зміни Docker-образу. 

Наведені вище параметри є мінімально необхідними для запуску працездатного сервера MariaDB у контейнері без додаткових сервісів і налаштувань.

- [ ] Перевірте, що контейнер працює:

```bash
docker ps
```

Команда `docker ps` використовується для перегляду запущених контейнерів. Вивід матиме приблизно такий вигляд:

```bash
CONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS      NAMES
b6fdf0d7edfb   mariadb   "docker-entrypoint.s…"   2 minutes ago   Up 2 minutes   3306/tcp   mariadb
```

де:

- `CONTAINER ID` - ідентифікатор контейнера;
- `IMAGE` -  образ, з якого створений контейнер;
- `COMMAND` - команда (процес), яка запускається всередині контейнера як основний; 
- `CREATED` - час, що минув з моменту створення контейнера;
- `STATUS` - поточний стан контейнера і тривалість його роботи;
- `PORTS` - інформація про відображення портів контейнера.
- `NAMES` -  ім’я контейнера;

Контейнер `mariadb` має статус `Up`.

Команда `docker ps` показує лише запущені контейнери, а `docker ps -a` — всі контейнери незалежно від їхнього стану. Цю команду ми використовуватиме нижче.

- [ ] Перегляньте журнали запуску MariaDB:

```bash
docker logs mariadb
```

У журналах має бути видно, що сервер бази даних успішно ініціалізувався і готовий приймати з’єднання. Образ MariaDB завантажений, контейнер бази даних запущений і працює.

### 3. Підключення до MariaDB та перевірка роботи БД

- [ ] Підключіться до MariaDB всередині контейнера:

```bash
docker exec -it mariadb mariadb -u root -p
```

де: 

- Команда `docker exec` дозволяє виконувати команди всередині запущеного контейнера, незалежно від типу сервісу, за умови що контейнер працює і необхідна команда присутня в його середовищі.
-  `-it` використовується тоді, коли потрібно спілкуватися з процесом усередині контейнера в режимі командного рядка, а не просто запустити його у фоновому режимі. 
- `mariadb` (перше) - Ім’я контейнера, всередині якого буде виконуватись команда.
- `mariadb` (друге) - Назва програми, яку потрібно запустити всередині контейнера. У цьому випадку це клієнт MariaDB (консольний SQL-клієнт).
- `-u root` - параметр клієнта MariaDB, який вказує користувача БД: `root` — адміністратор бази даних.
- `-p` - параметр клієнта MariaDB, який означає “запитати пароль”. 
- Після запуску команда попросить ввести пароль користувача `root`.

- [ ] Введіть пароль адміністратора БД (той, що задавали при запуску контейнера), наприклад `secret`

- [ ] Перевірте доступні бази даних:

```sql
SHOW DATABASES;
```

Має вивести перелік баз даних

- [ ] Створіть тестову базу даних:

```sql
CREATE DATABASE labdb;
```

- [ ] Переконайтесь, що база створена:

```sql
SHOW DATABASES;
```

- [ ] Вийдіть з клієнта MariaDB:

```sql
EXIT;
```

У результаті виконано підключення до MariaDB всередині контейнера, створено тестову базу даних, що підтверджує коректну роботу сервера БД.

### 4. Робота з контейнером

#### 4.1. Процеси в середині контейнера

- [ ] Перегляньте процеси контейнера з хоста:

```
docker top mariadb
```

Команда показує процеси, які Docker бачить усередині контейнера, без входу в нього.

- [ ] Запустіть перегляд процесів зсередини контейнера:

```
docker exec -it mariadb ps aux
```

Ця команда запускає утиліту `ps` всередині контейнера і показує всі активні процеси з точки зору контейнерного середовища. Зверніть увагу на основний процес сервера БД: процес `mariadbd` (або `mysqld`) який є головним і відповідає за роботу контейнера. Інший процес є тимчасовим і створюється лише для виконання команди, запущеної через `docker exec` (у даному випадку `ps`), після завершення якої цей процес одразу зникає і не впливає на роботу контейнера.

#### 4.2. Зупинка та повторний старт контейнера

- [ ] Зупиніть контейнер MariaDB:

```bash
docker stop mariadb
```

Контейнер зупиняється, але не видаляється, його файловий шар з даними залишається.

- [ ] Переконайтесь, що контейнер зупинений:

```bash
docker ps -a
```

Контейнер `mariadb` має статус `Exited`.

- [ ] Запустіть контейнер MariaDB знову:

```bash
docker start mariadb
```

- [ ] Переконайтесь, що контейнер працює:

```bash
docker ps
```

- [ ] Підключіться до MariaDB і перевірте наявність створеної раніше БД:

```bash
docker exec -it mariadb mariadb -u root -p
```

```
SHOW DATABASES;
```

- [ ] Вийдіть з клієнта MariaDB:

```sql
EXIT;
```

Після зупинки і повторного запуску контейнера MariaDB раніше створені бази даних залишилися доступними.

Docker-образ є незмінним і використовується лише як шаблон для контейнера. Контейнер має власний записуваний шар, у якому зберігаються всі зміни, зокрема дані БД. Операції `stop` і `start` не призводять до втрати даних, оскільки контейнер не видаляється. Дані будуть втрачені лише у разі видалення контейнера (`docker rm`) без використання Docker volume.

### 5. Ознайомлення з Docker volume та персистентністю даних

#### 5.1. Створення власного тома

- [ ] Перегляньте наявні Docker volumes:

```bash
docker volume ls
```

Навіть якщо користувач явно не створює volume, Docker може автоматично створювати анонімні томи для зберігання даних контейнера, але для керованої і передбачуваної роботи з даними слід використовувати іменовані volumes.

- [ ] Створіть іменований volume для даних MariaDB:

```bash
docker volume create mariadb_data
```

Volume призначений для зберігання даних БД незалежно від життєвого циклу контейнера.

- [ ] Переконайтесь, що volume створений:

```bash
docker volume ls
```

- [ ] Перегляньте детальну інформацію про volume:

```bash
docker volume inspect mariadb_data
```

Команда показує, де фізично зберігаються дані volume на хості та як ним керує Docker. Наприклад:

```json
[
    {
        "CreatedAt": "2025-12-30T13:25:52Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/mariadb_data/_data",
        "Name": "mariadb_data",
        "Options": null,
        "Scope": "local"
    }
]
```

Значить наступне

- `Name: "mariadb_data"` - Ім’я Docker volume, яке ви створили і використовуєте для зберігання даних.
- `Driver: "local"` - Тип драйвера volume. `local` означає, що дані зберігаються на локальному диску хоста і керуються самим Docker.
- `Mountpoint: "/var/lib/docker/volumes/mariadb_data/_data"` - Фізичний каталог на хості, де Docker реально зберігає файли цього volume.
- `CreatedAt: "2025-12-30T13:25:52Z"` - Час створення volume.
- `Scope: "local"` - Volume доступний лише на цьому хості (не розподілений між кількома вузлами).
- `Labels: null`, `Options: null` - Для цього volume не задано додаткових міток або параметрів.

Старий контейнер не можна “перепід’єднати” до нового volume, оскільки конфігурація монтування фіксується під час створення контейнера. Тому, щоб використати новий том, контейнер потрібно видалити і створити заново з потрібним volume.

#### 5.2. Створення нової версії контейнеру MariaDB 

- [ ] Зупиніть і видаліть старий контейнер MariaDB (без видалення volume)

```bash
docker stop mariadb
docker rm mariadb
```

- [ ] Переконайтесь, що контейнер видалений:

```
docker ps -a
```

- [ ] Запустіть новий контейнер і “прикріпіть” volume

```bash
docker ps -a
```

Для MariaDB дані всередині контейнера зберігаються у каталозі `/var/lib/mysql`, тому volume монтуємо саме туди:

```bash
docker run -d \
  --name mariadb \
  -e MARIADB_ROOT_PASSWORD=secret \
  -v mariadb_data:/var/lib/mysql \
  mariadb
```

де `-v mariadb_data:/var/lib/mysql` значить наступне:

- Ліва частина `mariadb_data` - ім’я Docker volume на хості.
- Права частина `/var/lib/mysql` - шлях у контейнері, куди Docker “підставляє” volume.

Завдяки цьому файли БД пишуться не в файлову систему контейнера, а в volume. Контейнер можна видалити, а дані не зникають.

- [ ] Перевірте, що volume реально змонтований у контейнер

```bash
docker inspect mariadb --format '{{json .Mounts}}'
```

У виводі має бути щось на кшталт:

```json
[{"Type":"volume","Name":"mariadb_data","Source":"/var/lib/docker/volumes/mariadb_data/_data","Destination":"/var/lib/mysql","Driver":"local","Mode":"z","RW":true,"Propagation":""}]
```

#### 5.3. Створення БД MariaDB 

- [ ] Створення тестової БД:

```bash
docker exec -it mariadb mariadb -uroot -psecret -e "CREATE DATABASE testdb;"
```

#### 5.4. Перевірка збереження БД в тому після перевидалення 

- [ ] Перезапуск через видалення:

```bash
docker stop mariadb
docker rm mariadb

docker run -d \
  --name mariadb \
  -e MARIADB_ROOT_PASSWORD=secret \
  -v mariadb_data:/var/lib/mysql \
  mariadb
```

Цей набір команд спочатку зупиняє і видаляє існуючий контейнер `mariadb`, а потім створює і запускає новий контейнер з тим самим ім’ям, але вже з підключеним Docker volume `mariadb_data`, у який монтується каталог `/var/lib/mysql` для збереження даних бази поза файловою системою контейнера.

- [ ] Перевірка, що БД `testdb` лишилась:

```bash
docker exec -it mariadb mariadb -uroot -psecret -e "SHOW DATABASES;"
```

### 6. Підключення до MariaDB з окремого контейнера

На попередніх етапах робота з БД виконувалась зсередини контейнера через `docker exec`. На практиці адміністрування БД зазвичай здійснюється з окремого клієнта. Для цього буде використано веб-адмінку з іменем Adminer, яка працює як окремий сервіс і підключається до MariaDB по мережі Docker.

#### 6.1. Створення окремої мережі Docker

- [ ] Створіть user-defined мережу з іменем `labnet`:

```bash
docker network create labnet
```

Окрема мережа дозволяє контейнерам знаходити один одного за іменами і є стандартною практикою для сервісної взаємодії.

- [ ] Переконайтесь, що мережа створена:

```bash
docker network ls
```

Виведе щось на кшталт:

```bash
NETWORK ID     NAME      DRIVER    SCOPE
404aa65e64b2   bridge    bridge    local
996f48fb4bff   host      host      local
a014f5c5462f   labnet    bridge    local
479cff49ae4e   none      null      local
```

де поля:

- `NETWORK ID` - Внутрішній ідентифікатор мережі Docker.
- `NAME` - Логічна назва мережі, яку використовують у командах Docker.
- `DRIVER` - Тип реалізації мережі (як Docker її будує).
- `SCOPE` - Область дії мережі (у цьому випадку тільки локальний хост).

Пояснення по рядках:

- `NAME = bridge, DRIVER = bridge` - Стандартна мережа Docker, створюється автоматично. Якщо мережу не вказано при `docker run`, контейнер підключається саме до неї.
- `NAME = host, DRIVER = host` - Контейнер використовує мережевий стек хоста без ізоляції.
- `NAME = none, DRIVER = null` - Контейнер запускається без мережевого доступу.
- `NAME = labnet, DRIVER = bridge` - User-defined bridge мережа, створена вручну для лабораторної роботи. Вона використовує той самий тип драйвера `bridge`, але має інші властивості, зокрема DNS за іменами контейнерів.

Однаковий DRIVER (`bridge`) не означає однакову поведінку мережі; означена користувачем мережа `labnet` і стандартна `bridge` реалізовані одним драйвером, але мають різні можливості і призначення.

#### 6.2. Підключення контейнера MariaDB до мережі

- [ ] Підключіть вже запущений контейнер MariaDB до мережі:

```bash
docker network connect labnet mariadb
```

Контейнер можна підключити до мережі без його перезапуску.

#### 6.3. Запуск контейнера Adminer

- [ ] Запустіть Adminer у тій самій мережі:

```bash
docker run -d \
  --name adminer \
  --network labnet \
  -p 8080:8080 \
  adminer
```

Adminer створюється і запускається як окремий контейнер та одразу підключається до мережі `labnet`. Порт 8080 відображений на хост для доступу до веб-інтерфейсу через браузер. Якщо Docker-образ `adminer` відсутній локально, команда `docker run` автоматично завантажує його з репозиторію перед створенням контейнера.

- [ ] Перевірте стан образів

```bash
docker images
```

#### 6.4. Підключення до MariaDB через Adminer

- [ ] Відкрийте у браузері хостової машини:

```
http://debian132:8080
```

де `debian132` - це ім'я віртуальної машини, або IP-адресу 

- [ ] Вкажіть параметри підключення:
- система: MariaDB / MySQL
- сервер: `mariadb`
- користувач: `root`
- пароль: `secret`

![image-20251230161835417](media/image-20251230161835417.png)

Ім’я контейнера `mariadb` використовується як ім’я сервера завдяки DNS-механізму user-defined мережі Docker.

#### 6.5. Перевірка доступу до даних

- [ ] Переконайтесь, що створена раніше база даних `testdb` доступна через Adminer
- [ ] (Опційно) Створіть таблицю або додайте тестовий запис

Веб-адмінка є окремим сервісом, а не частиною БД. Взаємодія між контейнерами здійснюється через user-defined мережу. Відображення портів використовується лише для доступу з хоста, а не для зв’язку між контейнерами. Така схема безпосередньо відповідає реальній сервісній архітектурі.

### 7. Аналіз схеми взаємодії контейнерів

На цьому етапі в лабораторній роботі використовується два контейнери (MariaDB і Adminer), які взаємодіють між собою через мережу Docker, а доступ користувача до сервісів здійснюється через відображення портів.

- [ ] Перевірте список запущених контейнерів:

```bash
docker ps
```

Очікуваний результат: Запущені контейнери `mariadb` і `adminer`.

- [ ] Перегляньте детальну інформацію про мережу:

```bash
docker network inspect labnet
```

У виводі буде видно, що обидва контейнери підключені до мережі `labnet` і мають власні IP-адреси. Наприклад:

```json
[
    {
        "Name": "labnet",
        "Id": "a014f5c5462fda8e70f66573d3749b11d4bf849d34d4a5e73c3c1dc96f5cc19e",
        "Created": "2025-12-30T13:59:30.060512346Z",
        "Scope": "local",
        "Driver": "bridge",
        "EnableIPv4": true,
        "EnableIPv6": false,
        "IPAM": {
            "Driver": "default",
            "Options": {},
            "Config": [
                {
                    "Subnet": "172.18.0.0/16",
                    "IPRange": "",
                    "Gateway": "172.18.0.1"
                }
            ]
        },
        "Internal": false,
        "Attachable": false,
        "Ingress": false,
        "ConfigFrom": {
            "Network": ""
        },
        "ConfigOnly": false,
        "Options": {},
        "Labels": {},
        "Containers": {
            "3a9482770931707be643459f473deb6f37deda1003c9a5b107ec380a55ea30ae": {
                "Name": "adminer",
                "EndpointID": "eaa226f75909c7286db43d4afb7c7024e0fb849010b2b681ac9c397719a99adc",
                "MacAddress": "02:0f:35:13:0b:ef",
                "IPv4Address": "172.18.0.3/16",
                "IPv6Address": ""
            },
            "6dda63622c0d1ccbf1cf76cedb9f3490f5420fd365ef499cf2b454216de4ffdd": {
                "Name": "mariadb",
                "EndpointID": "31e75a8ac0b9bb64ca1e1770cb161541d8e2c87c20812f0c952b945c6fe343d3",
                "MacAddress": "22:c6:4e:0e:fe:45",
                "IPv4Address": "172.18.0.2/16",
                "IPv6Address": ""
            }
        },
        "Status": {
            "IPAM": {
                "Subnets": {
                    "172.18.0.0/16": {
                        "IPsInUse": 5,
                        "DynamicIPsAvailable": 65531
                    }
                }
            }
        }
    }
]

```

У мережі означеної користувачем Docker кожен контейнер автоматично отримує DNS-ім’я, яке збігається з його іменем. У цій лабораторній:

- ім’я сервера БД: `mariadb`
- це ім’я використовується в Adminer як адреса сервера

- [ ] Зверніть увагу на параметр запуску Adminer:

```text
-p 8080:8080
```

Відображення порту використовується лише для доступу з хоста до контейнера Adminer. Для взаємодії контейнерів між собою відображення портів не потрібне.

Кожен контейнер є окремим сервісом. Взаємодія між сервісами здійснюється через означену користувачем мережу Docker. Імена контейнерів використовуються як мережеві імена сервісів. Відображення портів потрібне лише для доступу ззовні Docker-середовища. Така схема є типовою для подальшого переходу до Docker Compose.

## Частина 2. Docker Compose

На попередній частині лабораторної роботи всі сервіси створювалися вручну за допомогою команд Docker, без використання конфігураційних файлів. У системі вже існують окремі об’єкти Docker: контейнери, мережа та Docker volume з даними бази даних. Окремої конфігурації у вигляді файлу ще не існує, але поточний стан середовища фактично виконує її роль. 

Для опису та керування багатосервісними середовищами існують спеціальні інструменти оркестрації, які дозволяють фіксувати таку конфігурацію декларативно, у вигляді структурованого опису. Один із них - Docker Compose, який є простим і зручним інструментом, призначеним для локальної розробки та навчальних сценаріїв, і виступає логічним продовженням ручної роботи з Docker. Наразі Docker Compose інтегрований у Docker і використовується як підкоманда `docker compose`, тоді як раніше він постачався як окремий інструмент.

У цій частині Ви попрактикуєтеся у впорядкуванні вже створеного Docker-середовища та ознайомитеся з підходом декларативного опису сервісів за допомогою Docker Compose як зручного механізму керування багатоконтейнерними конфігураціями.

У наступній, третій частині лабораторної роботи, це середовище буде доповнене вебінтерфейсом Portainer, який дозволяє візуально переглядати та керувати контейнерами, образами, мережами і томами, а також спостерігати, як конфігурація, описана в Docker Compose, відображається у реальному стані Docker-системи.

Перед переходом до Docker Compose доцільно зупинити і видалити вручну створені контейнери, зберігши дані у Docker volume, щоб подальше керування середовищем виконувалося вже засобами Compose.

### 8. Зупинка та видалення контейнерів 

- [ ] Перевірте список запущених контейнерів:

```bash
docker ps
```

У списку повинні бути присутні контейнери `mariadb` та `adminer`.

- [ ] Зупиніть контейнер Adminer:

```bash
docker stop adminer
```

- [ ] Зупиніть контейнер MariaDB:

```bash
docker stop mariadb
```

- [ ] Переконайтесь, що контейнери зупинені:

```bash
docker ps -a
```

Контейнери `adminer` та `mariadb` мають мати статус `Exited`.

- [ ] Видаліть контейнер Adminer:

```bash
docker rm adminer
```

- [ ] Видаліть контейнер MariaDB:

```bash
docker rm mariadb
```

- [ ] Переконайтесь, що контейнери видалені:

```bash
docker ps -a
```

Контейнери `adminer` та `mariadb` повинні бути відсутні у списку.

Контейнер і образ є різними об’єктами Docker; видалення контейнера не впливає на наявність образу у локальному репозиторії. 

- [ ] Перевірте які образи є в локальному репозиторії. 

```
docker images
```

Має залишитися обидва образи

- [ ] Перевірте, що томи Docker (volume) з даними також залишився:

```bash
docker volume ls
```

Тому `mariadb_data` присутній у системі.

Таким чином вручну створені контейнери зупинені та видалені, при цьому дані бази даних збережені у Docker volume

### 9. Запуск середовища за допомогою Docker Compose

На попередніх етапах сервіси створювалися і запускалися вручну окремими командами Docker. Docker Compose дозволяє описати те саме середовище у вигляді одного файлу та керувати всіма сервісами як єдиним цілим.

#### 9.1. Підготовка робочого каталогу

- [ ] Створіть окремий каталог для конфігурації Docker Compose:

```bash
mkdir compose
cd compose
```

Docker Compose використовує файл конфігурації, який зберігається у робочому каталозі.

#### 9.2. Створення файлу конфігурації Docker Compose

- [ ] Створіть файл `docker-compose.yml`

```bash
nano docker-compose.yml
```

- [ ] Скопіюйте туди наступним вміст:

```yaml
services:
  mariadb:
    image: mariadb
    container_name: mariadb
    environment:
      MARIADB_ROOT_PASSWORD: secret
    volumes:
      - mariadb_data:/var/lib/mysql

  adminer:
    image: adminer
    container_name: adminer
    ports:
      - "8080:8080"
    depends_on:
      - mariadb

volumes:
  mariadb_data:
    external: true
    name: mariadb_data
```

- [ ] Натисніть `Ctrl+X` потім `Y` , потім `Enter` для збереження файлу.

Цей файл `docker-compose.yml` описує два сервіси, які працюють разом: базу даних MariaDB і вебінтерфейс для роботи з нею, а також підключає вже існуючий Docker volume для збереження даних. Пояснення по розділах

`services` - Описує контейнери, які мають бути створені та запущені в межах одного compose-проєкту.

`mariadb` - Сервіс бази даних.

- `image: mariadb` вказує, що контейнер створюється з офіційного образу MariaDB.
- `container_name: mariadb` задає фіксоване ім’я контейнера, а не автоматичне ім’я Compose.
- `environment` передає змінні середовища в контейнер. `MARIADB_ROOT_PASSWORD` задає пароль користувача root під час першого запуску.
- `volumes` підключає Docker volume `mariadb_data` до каталогу `/var/lib/mysql` всередині контейнера, де MariaDB зберігає свої файли.

`adminer` - Сервіс вебінтерфейсу для адміністрування бази даних.

- `image: adminer` використовує готовий образ Adminer.
- `container_name: adminer` фіксує ім’я контейнера.
- `ports` проброшують порт 8080 контейнера на порт 8080 хоста, щоб вебінтерфейс був доступний з браузера.
- `depends_on` вказує, що контейнер Adminer має запускатися після контейнера MariaDB.

`volumes` - Описує volumes, які використовуються у compose-проєкті.

- `external: true` означає, що volume не створюється Docker Compose, а вже існує в системі.
- `name: mariadb_data` задає точне ім’я існуючого volume, який буде підключений до контейнера MariaDB.

Тобто Docker Compose запускає пов’язаний набір контейнерів як єдине середовище, при цьому дані MariaDB зберігаються у вже створеному volume і не залежать від життєвого циклу контейнерів.

#### 9.3. Запуск сервісів через Docker Compose

- [ ] Запустіть середовище:

```bash
docker compose up -d
```

де:

`up` - створює і запускає всі сервіси, описані у файлі `docker-compose.yml`.

- створює мережі;
- створює томи;
- створює контейнери;
- запускає контейнери у правильному порядку.

`-d` (*detached mode*) - запускає сервіси у фоновому режимі, тобто консоль не блокується і повертається керування користувачу. Без `-d` журнали сервісів виводилися прямо в консоль, робота зупинялася до завершення виконання.

- [ ] Перевірте стан сервісів:

```bash
docker compose ps
```

Сервіси `mariadb` та `adminer` мають мати статус `running`.

#### 9.4. Перевірка доступу до сервісів

- [ ] Використовуючи Adminer gереконайтесь , що БД  `testdb` існує 


Середовище MariaDB та Adminer розгорнуте і керується за допомогою Docker Compose, а дані бази даних зберігаються у Docker-томі.

- Docker Compose дозволяє описати багатосервісне середовище у вигляді одного файлу.
- Один файл замінює набір команд `docker run`, `docker network` і `docker volume`.
- Керування сервісами стає відтворюваним і зручним.
- Такий підхід є базовим для подальшого розгортання складніших систем.

### 10. Поведінка контейнерів після перезавантаження системи

#### 10.1. Перевірка стану контейнерів після перезапуску

- [ ] Перезапустіть віртуальну машину

```bash
sudo reboot
```

- [ ] Після перезапуску перевірте стан контейнерів

```
docker ps
```

Список буде порожній.

Після перезавантаження операційної системи Docker Engine запускається автоматично, однак контейнери, створені за допомогою Docker Compose, не запускаються самі по собі. Це пов’язано з тим, що Docker Compose є інструментом керування і опису середовища, а не службою, яка постійно працює у фоні. У результаті після перезапуску системи: Docker працює, але сервіси, описані у `docker-compose.yml`, залишаються зупиненими.

Щоб контейнери запускалися автоматично разом із Docker Engine, необхідно задати політику перезапуску контейнерів.

#### 10.2. Добавлення політики автоматичного перезапуску

У Docker Compose політика перезапуску контейнерів налаштовується параметром `restart` для кожного сервісу:

```yaml
restart: unless-stopped
```

Ця політика означає, що контейнер буде автоматично запускатися після перезавантаження системи, доки його не зупинять вручну.

- [ ] Запустіть редактор для редагування `docker-compose.yml`

```bash
cd compose
nano docker-compose.yml
```

- [ ] За допомогою `Ctrl+K` видаліть увесь зміст
- [ ] Скопіюйте у файл модифікований варіант, де вставлені два рядки `restart: unless-stopped`

```yaml
services:
  mariadb:
    image: mariadb
    container_name: mariadb
    environment:
      MARIADB_ROOT_PASSWORD: secret
    volumes:
      - mariadb_data:/var/lib/mysql
    restart: unless-stopped

  adminer:
    image: adminer
    container_name: adminer
    ports:
      - "8080:8080"
    restart: unless-stopped

volumes:
  mariadb_data:
    external: true
    name: mariadb_data
```

- [ ] Натисніть `Ctrl+X` потім `Y` , потім `Enter` для збереження файлу.

- [ ] Запустіть середоивще

```bash
docker compose up -d
```

#### 10.3. Повторна перевірка стану контейнерів після перезапуску

- [ ] Перезапустіть віртуальну машину

```bash
sudo reboot
```

- [ ] Після перезапуску перевірте стан контейнерів

```
docker ps
```

Там повинні бути два запущені контейнери.

Після додавання політики перезапуску:

- система перезавантажується;
- Docker Engine стартує як служба;
- Docker автоматично запускає контейнери;
- запуск Docker Compose вручну не потрібен.

#### 10.4. Зупинка та видалення контейнерів

Docker Compose керує середовищем, означеним у конкретному файлі конфігурації, тому команди Compose прив’язані до каталогу або до явно вказаного файлу `docker-compose.yml`.

- [ ] Зупиніть виконання контейнерів

```bash
cd compose
docker compose stop
```

- [ ] Після перезапуску перевірте стан контейнерів

```bash
docker ps
```

- [ ] Виведіть список усіх контейнерів docker

```bash
docker ps -a
```

`docker ps` без параметрів показує тільки запущені контейнери, а ключ `-a` додає до списку зупинені та завершені.

- [ ] Видаліть усі контейнери що створені  compose

```
docker compose down
```

- [ ] Перевірте що контейнери дійсно були видалені

```
docker ps -a
```



## Частина 3. Portainer

to do



## Джерела

1. 


## Автори


Практичне заняття розробив  [Олександр Пупена](https://github.com/pupenasan). 

## Feedback

Якщо Ви хочете залишити коментар у Вас є наступні варіанти:

- [Обговорення у WhatsApp](https://chat.whatsapp.com/BRbPAQrE1s7BwCLtNtMoqN)
- [Обговорення в Телеграм](https://t.me/+GA2smCKs5QU1MWMy)
- [Група у Фейсбуці](https://www.facebook.com/groups/asu.in.ua)

Про проект і можливість допомогти проекту написано [тут](https://asu-in-ua.github.io/atpv/)
