За замовчуванням libgpiod дотримується підходу Linux до роботи з периферією: процес отримує контроль над ресурсом, використовує його, а після завершення повертає у попередній стан. Це означає, що немає гарантії, що після завершення програми, яка встановила певне значення GPIO, це значення збережеться. Лінія може або залишитися в новому стані, або бути повернена до попереднього.

Щоб полегшити перехід від постійної моделі керування, яка була характерна для sysfs, у ядрі Raspberry Pi змінено цю поведінку: стан GPIO зберігається навіть після завершення програми, яка його змінила (наприклад, gpioset). Автоматичне повернення GPIO до попереднього стану можна знову увімкнути, додавши до файлу `config.txt` такий рядок:

```
dtparam=strict_gpiod
```

Або ж додавши до командного рядка ядра (`cmdline.txt`) наступний параметр:

```
pinctrl_bcm2835.persist_gpio_outputs=n
```

Окремою важливою властивістю libgpiod є гарантія ексклюзивного доступу до GPIO. Поки лінія захоплена через libgpiod, жодна інша програма не зможе нею користуватися, доки доступ не буде звільнено. Жодна з інших поширених бібліотек такого механізму не забезпечує.

Проєкт [libgpiod](https://libgpiod.readthedocs.io/en/latest/gpio_tools.html) містить набір утиліт командного рядка, призначених для керування GPIO безпосередньо з консолі або shell-скриптів. Ці інструменти реалізують роботу з сучасним character device API і дозволяють працювати з GPIO без використання застарілого sysfs. На даний момент доступні такі консольні утиліти:

- `gpiodetect` - виводить список усіх GPIO-контролерів (gpiochip), наявних у системі, разом з їхніми іменами, мітками та кількістю GPIO-ліній у кожному контролері.
- `gpioinfo` - виводить детальну інформацію про GPIO-лінії: до якого gpiochip вони належать, їхній локальний номер (offset), ім’я, напрямок, а також інформацію про використання. Якщо лінія зайнята, показується назва споживача і додаткові атрибути, такі як активний рівень, підтяжки, режим драйву, обробка фронтів і debounce.

- `gpioget` - зчитує поточні логічні значення вказаних GPIO-ліній.

- `gpioset` - встановлює логічні значення на вказаних GPIO-лініях і утримує їх у цьому стані, поки процес працює або не буде завершений.

- `gpiomon` - очікує подій на GPIO-лініях, пов’язаних зі зміною стану. Дозволяє вказати типи фронтів, кількість подій або режим безперервного моніторингу з виводом у консоль.

- `gpionotify` - відстежує зміни інформації про GPIO-лінії, наприклад зміну стану зайнятості або атрибутів, і повідомляє про ці події у консоль.

Цей набір утиліт формує практичний мінімум для роботи з GPIO з консолі Linux і дозволяє побачити, як абстрактна модель GPIO, реалізована в ядрі, відображається у реальних командах і результатах їх виконання. Саме з них доцільно починати знайомство з програмним керуванням GPIO без написання власного коду.





### GPIO у моделі операційної системи Linux

У Linux GPIO не є просто фізичними контактами мікросхеми або плати. З точки зору операційної системи GPIO – це логічні лінії вводу-виводу (GPIO **Lines**), якими керує ядро Linux. Кожна така лінія пов’язана з конкретним апаратним контактом, але доступ до неї здійснюється не напряму, а через програмну модель, яку підтримує ОС. Це дозволяє системі контролювати, хто і як користується цими лініями, і не допускати конфліктів між різними програмами або драйверами.

Апаратно GPIO завжди належать певному контролеру – наприклад, контролеру в SoC, окремому чипу-розширювачу або логіці в FPGA. У Linux такий контролер представлений як **GPIO chip**. Один GPIO chip містить кілька окремих GPIO-ліній, кожна з яких має власний номер усередині цього контролера та набір властивостей: напрямок (вхід або вихід), логічний активний рівень, можливість генерувати переривання тощо. Усе це описується і зберігається всередині ядра.

Ядро Linux виступає посередником між апаратурою та програмами. Воно знає, які GPIO-лінії існують, які з них доступні, і хто наразі ними користується. Програми не працюють із GPIO напряму, а звертаються до ядра, яке або дозволяє керування, або відмовляє, якщо лінія вже зайнята чи недоступна. Саме тому одна й та сама GPIO-лінія не може одночасно керуватися кількома різними компонентами без відома ОС.

Термін **userspace** означає звичайні програми користувача, які працюють у просторі користувача, на відміну від коду ядра. Це можуть бути консольні утиліти, служби або прикладні програми. Вони не мають прямого доступу до апаратури і завжди взаємодіють з нею через інтерфейси, які надає ядро. У випадку GPIO такими інтерфейсами є спеціальні пристрої та бібліотеки, через які userspace-програми можуть запитувати стан GPIO або тимчасово брати їх під керування.

### Загальна ідея програмного доступу до GPIO

Описана вище модель GPIO існує всередині ядра Linux. Щоб прикладні програми могли з нею працювати, ядро надає спеціальні програмні інтерфейси. Саме вони визначають, як GPIO виглядають з боку консолі та прикладних програм, і якими засобами ними дозволено керувати.

На концептуальному рівні програмний доступ до GPIO в Linux еволюціонував від простих файлових інтерфейсів до чітко визначеної моделі пристроїв і ліній GPIO. Ранні механізми були зручні для навчання, але погано масштабувалися і не враховували реальні сценарії конкурентного доступу, пріоритетів і подій.

Найнижчим рівнем залишається прямий доступ до регістрів GPIO через **memory-mapped I/O**. У цьому випадку програма безпосередньо читає і записує апаратні регістри SoC. Такий підхід забезпечує мінімальні затримки, але вимагає привілейованого доступу, жорстко прив’язаний до конкретної платформи і фактично обходить модель керування ресурсами Linux. У загальносистемних, навчальних і прикладних сценаріях він практично не використовується.

Традиційним інтерфейсом ядра для роботи з GPIO був **sysfs**, який представляв GPIO у вигляді файлів у файловій системі. Через нього можна було експортувати лінію, задати напрям і читати або записувати значення. Цей підхід довгий час використовувався в прикладах і навчальних матеріалах, але в сучасних версіях ядра Linux він вважається застарілим і поступово вилучається. Нові системи можуть взагалі не мати підтримки sysfs для GPIO.

Актуальним механізмом доступу до GPIO з простору користувача є **character device API**, який представляє контролери GPIO у вигляді символьних пристроїв `/dev/gpiochipN`. У цій моделі GPIO розглядаються як лінії, що належать певному GPIO-контролеру, з чітко означеними властивостями, напрямом, станом і можливістю генерації подій. Саме ця модель є базовою для сучасного Linux. Для роботи з цим інтерфейсом з консолі та з прикладних програм зазвичай використовують бібліотеку `libgpiod` і пов’язані з нею утиліти командного рядка. Вони дозволяють переглядати доступні GPIO-контролери, їхні лінії, читати і змінювати стани, а також працювати з подіями, не звертаючись до застарілих механізмів. Саме ці інструменти формують практичну основу сучасного консольного керування GPIO.

У межах цієї лекції як базовий інструмент програмного керування GPIO з консолі розглядається `character device API` разом з утилітами `libgpiod`. Це дозволяє одразу працювати з актуальною моделлю GPIO в Linux і сформувати правильне уявлення про те, як ядро представляє апаратні лінії і керує доступом до них. Інші високорівневі підходи, зокрема бібліотеки мов програмування та середовища автоматизації, логічно розглядати вже поверх цієї моделі. Застарілий sysfs варто розглядати лише для розуміння історичних прикладів або роботи зі старими системами.

### Модель GPIO у консольному інтерфейсі Linux

У сучасному Linux робота з GPIO з консолі будується навколо простої, але чіткої ідеї: користувач не керує «пінами плати» напряму, а працює з логічними GPIO-лініями, згрупованими за апаратними контролерами. Усі дії виконуються через ядро операційної системи, яке надає стандартизований інтерфейс доступу до цих ліній. З погляду консолі це означає, що GPIO з’являються в системі як спеціальні пристрої, а не як довільні номери або адреси.

Консольний спосіб роботи з GPIO не передбачає програмування на мовах високого рівня. Користувач взаємодіє з GPIO за допомогою стандартних утиліт командного рядка, які звертаються до ядра Linux через character device API. Саме цей підхід є актуальним для сучасних систем і замінює застарілий файловий інтерфейс sysfs.

Для такої роботи використовується набір інструментів проєкту libgpiod. Ці утиліти дозволяють досліджувати наявні GPIO-контролери, переглядати структуру GPIO-ліній, читати їхній стан, змінювати значення та відстежувати події без написання власного коду. Вони безпосередньо відображають ту модель GPIO, яку реалізує ядро Linux, і тому є зручним навчальним інструментом для розуміння принципів керування GPIO з консолі. На платформах типу Raspberry Pi утиліти `libgpiod` зазвичай вже присутні у стандартних образах Raspberry Pi OS або легко встановлюються зі штатних репозиторіїв, тому для роботи з GPIO з консолі не потрібне додаткове налаштування чи збирання інструментів вручну.

На практиці робота з GPIO починається з ознайомлення зі структурою контролерів і ліній у системі, після чого використовуються відповідні консольні утиліти для перегляду інформації та керування станами. Саме з цієї точки логічно перейти до огляду конкретних інструментів libgpiod і того, яку інформацію вони показують користувачеві.



#### GPIO-контролери

Кожен GPIO-контролер у системі представлений спеціальним символьним пристроєм у каталозі `/dev`. Такі пристрої мають імена виду `/dev/gpiochip0`, `/dev/gpiochip1` і так далі. Перевірити, які GPIO-контролери бачить система, можна звичайною командою перегляду файлів у каталозі `/dev`, оскільки в Linux апаратні пристрої представлені у вигляді спеціальних файлів пристроїв:

```bash
ls -1 /dev/gpiochip*
```

У відповідь система виведе список доступних GPIO-контролерів. Кожен з них відповідає одному реальному апаратному джерелу GPIO: вбудованому контролеру SoC, зовнішньому розширювачу або іншому пристрою, який надає GPIO-лінії. Якщо в системі кілька таких контролерів, у каталозі `/dev` буде кілька пристроїв виду `gpiochipN`. Наприклад:

```bash
/dev/gpiochip0
/dev/gpiochip10
/dev/gpiochip11
/dev/gpiochip12
/dev/gpiochip13
/dev/gpiochip4
```

Нумерація `gpiochipN` не є послідовною і не несе фізичного змісту для користувача. Ці номери присвоюються ядром під час ініціалізації драйверів і можуть змінюватися між перезавантаженнями або при зміні конфігурації системи. Тому вивід на кшталт `gpiochip0`, `gpiochip4`, `gpiochip10` є нормальним і не означає помилки чи пропусків.

Для користувача консолі цей список є початковою точкою роботи з GPIO: він показує, з якими GPIO-контролерами взагалі можна працювати в системі. На цьому етапі ще не видно, скільки GPIO-ліній містить кожен контролер і які з них доступні, але вже зрозуміло, що модель GPIO в Linux побудована навколо контролерів, а не окремих «глобальних» номерів контактів.

Після того як ми побачили в системі символьні пристрої `/dev/gpiochipN`, виникає питання: що це за контролери і скільки GPIO-ліній кожен з них надає. Для цього в `libgpiod` є утиліта `gpiodetect`, яка працює поверх character device API і читає цю інформацію безпосередньо з ядра. Типовий виклик з консолі виглядає так:

```bash
gpiodetect
```

У відповідь система виводить список усіх GPIO-контролерів, присутніх у системі, у зрозумілому вигляді: для кожного `gpiochip` показується його внутрішня назва, мітка (label) і кількість GPIO-ліній. Саме з цього виводу зазвичай починають роботу з GPIO з консолі, оскільки він дає первинне уявлення про те, які контролери реально доступні і з чим далі доведеться працювати. У контексті Raspberry Pi у цьому списку зазвичай можна побачити основний GPIO-контролер SoC, а також додаткові контролери, пов’язані з допоміжними підсистемами або розширеннями. Це і є перший крок до розуміння моделі GPIO з боку операційної системи перед переходом до аналізу окремих ліній. 

Ось приклад виведення:

```bash
gpiochip0 [pinctrl-rp1] (54 lines)
gpiochip10 [gpio-brcmstb@107d508500] (32 lines)
gpiochip11 [gpio-brcmstb@107d517c00] (17 lines)
gpiochip12 [gpio-brcmstb@107d517c20] (6 lines)
gpiochip13 [gpio-brcmstb@107d508520] (4 lines)
```

Виведений результат пояснюється в [білій книзі GPIO Usage on Raspberry Pi Devices](https://www.google.com/url?sa=t&source=web&rct=j&opi=89978449&url=https://pip.raspberrypi.com/categories/685-whitepapers-app-notes/documents/RP-006553-WP/A-history-of-GPIO-usage-on-Raspberry-Pi-devices-and-current-best-practices.pdf)). У Raspberry Pi моделей 0–2 усі GPIO-піни керуються безпосередньо самим SoC, тобто існує пряме з’єднання між SoC і фізичними контактами на платі. Починаючи з Raspberry Pi 3, кількості GPIO, доступних у SoC, вже не вистачало для керування всією периферією і водночас збереження тієї самої розводки GPIO, що й у попередніх моделях, тому було використано чип-розширювач GPIO, підключений через I2C. У результаті в Linux створюються два gpiochip: один для GPIO-ліній, що надаються SoC, і один для ліній GPIO розширювача. У Raspberry Pi 5 ситуація ще складніша. Сам SoC (BCM2712) має чотири окремі апаратні блоки GPIO (які забезпечують постійно активні та інші функції), а чип RP1 надає GPIO-лінії, доступні користувачу. У результаті в системі створюється п’ять gpiochip. GPIO, доступні користувачу, тепер знаходяться на `gpiochip0`, так само як і в попередніх моделях. Внутрішні системні GPIO були перенесені на `gpiochip` з номерами 10 і вище, щоб підкреслити, що це пристрої системного рівня.

Усередині кожного gpiochip знаходиться набір GPIO-ліній. Лінія є логічним представленням одного фізичного контакту. Вона має власний номер, але цей номер є локальним для конкретного gpiochip. Тобто «лінія 4» має сенс лише в контексті конкретного `/dev/gpiochipN`. Глобальної нумерації GPIO, з якою працює користувач, у цій моделі більше не існує.

З консолі користувач працює саме з цією ієрархією: спочатку обирається gpiochip, а потім конкретна лінія всередині нього. Наприклад, утиліти можуть звертатися до «лінії 17 контролера gpiochip0». Такий підхід дозволяє системі чітко відслідковувати, хто і з якою апаратною частиною працює, і запобігати конфліктам.

Кожна GPIO-лінія має набір властивостей, які відображаються і використовуються в консольному інтерфейсі. До них належать напрям роботи (вхід або вихід), логічний активний рівень, поточний стан, а також інформація про те, чи зайнята ця лінія якимось драйвером або програмою. Якщо лінія вже використовується системою або іншим процесом, інструменти з консолі покажуть її як зайняту і не дозволять взяти під керування без звільнення.

Ця модель добре видно на практиці вже з першої команди. Коли користувач запускає утиліту для перегляду GPIO, система не показує «таблицю пінів», а виводить список gpiochip-контролерів, а для кожного з них — перелік GPIO-ліній з їхніми властивостями. Саме з такого огляду починається будь-яка робота з GPIO з консолі: спочатку потрібно зрозуміти, які контролери є в системі і які лінії доступні.

Таким чином, консольна модель GPIO в Linux будується за принципом «контролер → лінія → стан». Користувач мислить не фізичними контактами плати, а логічними лініями, якими керує операційна система. Це може виглядати менш інтуїтивно для початківця, але саме така модель дозволяє Linux безпечно і узгоджено керувати GPIO в багатозадачному середовищі.

У наступному підрозділі ця модель буде розглянута вже на реальному прикладі — через вивід утиліти `gpiinfo`, яка показує GPIO саме в тому вигляді, в якому їх бачить користувач з консолі.