[<- До підрозділу](README.md)

# systemd: теоретична частина

## 1. Загальні поняття

Менеджер системи і служб `systemd` — це сучасне системне програмне забезпечення для ініціалізації та керування службами, яка стала стандартом у більшості сучасних дистрибутивів Linux. Вона відповідає за запуск і контроль фонових процесів (демонів), монтування файлових систем, ініціалізацію мережі, логування, а також забезпечує послідовний і паралельний запуск служб під час завантаження системи. `systemd` приходить на зміну традиційним системам, таким як SysVinit, пропонуючи більш ефективну, модульну та уніфіковану архітектуру для керування ресурсами та процесами в Linux.

**Служба** (англ. *service*) — це фоновий процес (**демон**), який виконує певну функцію в операційній системі, наприклад, обслуговує мережеві з'єднання, веде журнал подій, надає доступ до файлів, обробляє друк тощо. 

Адміністратор або система повинні:

- Запускати служби (`start`) вручну або автоматично при завантаженні системи.
- Зупиняти служби (`stop`) коли вони більше не потрібні або для обслуговування.
- Перезапускати служби (`restart`) наприклад, після зміни конфігурації.
- Перевіряти статус служб (`status`) щоб переконатися, що вони працюють правильно.
- Керувати автозапуском (`enable` / `disable`) означувати, чи повинна служба запускатися під час старту системи.
- Перевантажувати конфігурацію (`reload`) застосовувати зміни без повного перезапуску.

У `systemd` служби описуються за допомогою спеціальних **unit-файлів** з типом `service`, які містять інструкції щодо запуску, зупинки, перезапуску та інших параметрів роботи цих процесів.

Менеджер `systemd` виконує роль `PID 1`, тобто першого процесу, який запускається після ядра Linux. Він відповідає за:

- запуск усіх інших процесів і служб (через юніти — `unit` файли),
- керування залежностями між службами,
- паралельний запуск служб для пришвидшення старту системи,
- монтування файлових систем,
- логування (через `journald`),
- керування сесіями користувачів (`logind`),
- таймери замість cron (`systemd-timers`),
- мережу (через `systemd-networkd`, якщо використовується),
- інші допоміжні функції.

Керування службами робиться за допомогою команди `systemctl`, яка є основним інструментом взаємодії з `systemd`. Приклади:

```bash
sudo systemctl start nginx       # запуск служби
sudo systemctl stop nginx        # зупинка служби
sudo systemctl restart nginx     # перезапуск служби
sudo systemctl status nginx      # перевірка статусу
sudo systemctl enable nginx      # додати до автозапуску
sudo systemctl disable nginx     # прибрати з автозапуску
```

Щоб переглянути перелік усіх служб у системі, які розпізнає `systemd`, використовується команда:

```
systemctl list-units --type=service
```

Ця команда покаже активні (завантажені) служби, тобто ті, які зараз виконуються або перебувають у іншому активному стані (наприклад, "failed", "activating"). Якщо потрібно побачити всі служби (і активні, і неактивні, і встановлені, але не запущені), використовуйте:

```
systemctl list-unit-files --type=service
```

Цей список показує, які служби:

- `enabled` — вмикаються автоматично при старті;
- `disabled` — не запускаються автоматично;
- `static` — не мають секції [Install] і не можуть бути ввімкнені напряму;
- `masked` — заблоковані (їх неможливо запустити).

## 2. Створення служби

Щоб зробити програму службою в системі з systemd, необхідно створити відповідний unit-файл типу service, який описує правила запуску, зупинки, перезапуску та інші параметри виконання програми у фоновому режимі. Програми, які доцільно запускати як служби:

- серверні програми (наприклад, nginx, apache2, postgresql, mosquitto);
- системні агенти (наприклад, cron, sshd, telegraf);
- власні скрипти або бінарні файли, які повинні працювати безперервно у фоновому режимі;
- консольні програми, які не потребують взаємодії з користувачем.

Програми, які не слід запускати як служби:

- графічні програми (наприклад, браузери, текстові редактори з GUI), що потребують середовища користувача;
- утиліти з коротким часом виконання, які не призначені для постійної роботи;
- інструменти, що залежать від постійної взаємодії з користувачем у терміналі.

Процедура створення служби:

1) Створити unit-файл у каталозі `/etc/systemd/system`, наприклад:

```
/etc/systemd/system/myservice.service
```

2) У файлі вказати основні параметри. Наприклад:

```
[Unit]
Description=My Custom Service
After=network.target

[Service]
ExecStart=/usr/local/bin/my_script.sh
Restart=always
User=nobody
Group=nogroup

[Install]
WantedBy=multi-user.target
```

3) Перезавантажити конфігурацію systemd:

```
sudo systemctl daemon-reexec
```

або, якщо unit-файл було змінено:

```
sudo systemctl daemon-reload
```

4) Запустити та керувати службою:

```
sudo systemctl start myservice
sudo systemctl status myservice
sudo systemctl enable myservice
```

Примітки:

- Якщо програма не демонізує себе самостійно, `systemd` може працювати з нею напряму, не вимагаючи фонової реалізації.
- Якщо програма має вивід у `stdout` або `stderr`, ці повідомлення будуть автоматично зібрані журналом `systemd` і доступні через `journalctl`.
- Для інтерпретованих мов програмування (наприклад, Python або Node.js) бажано вказувати повний шлях до інтерпретатора та скрипта у параметрі ExecStart.

Висновок: будь-яку програму, здатну працювати у фоновому режимі та не залежну від графічного інтерфейсу, можна зробити службою `systemd` шляхом створення відповідного unit-файлу.

## 3. Конфігурування служби 

### Через редагування файлів

Конфігурування служби в systemd передбачає створення або зміну unit-файлу типу service, який визначає, як служба має запускатися, зупинятися, перезапускатися, з якими правами користувача працювати та інші параметри. Це дозволяє адаптувати поведінку служби до потреб системи або конкретного застосування. Розміщення unit-файлів:

- `/etc/systemd/system/` - рекомендоване місце для користувацьких або змінених unit-файлів (має пріоритет).
- `/lib/systemd/system/` - unit-файли, встановлені пакетами.
- `/run/systemd/system/` - тимчасові unit-файли, створені динамічно.

Юніт-файл має розширення `.service` і зазвичай містить три основні секції:

- `[Unit]` Містить загальні відомості про службу та залежності:

```
[Unit]
Description=Короткий опис служби
After=network.target
```

- `[Service]` Означує поведінку самої служби:

```
[Service]
ExecStart=/usr/local/bin/myscript.sh
Restart=on-failure
User=someuser
WorkingDirectory=/var/lib/myapp
```

Основні параметри:

- `ExecStart` — шлях до виконуваного файлу або скрипта;
- `Restart` — умови перезапуску (`always`, `on-failure`, `no`);
- `User` і `Group` — під яким користувачем/групою запускати процес;
- `Environment` — оголошення змінних середовища;
- `WorkingDirectory` — робочий каталог для процесу;
- `ExecStop`, `ExecReload` — команди для зупинки або перезавантаження.

- `[Install]` означує, коли служба має активуватися:

```
[Install]
WantedBy=multi-user.target
```

Цей розділ дозволяє systemd вмикати службу для автозапуску.

Наприклад: 

1. Створіть або відредагуйте файл, наприклад:

   ```
   sudo nano /etc/systemd/system/myservice.service
   ```

2. Після внесення змін застосуйте їх:

   ```
   sudo systemctl daemon-reload
   ```

3. За потреби увімкніть службу для автозапуску:

   ```
   sudo systemctl enable myservice
   ```

4. Запустіть службу:

   ```
   sudo systemctl start myservice
   ```

У системі systemd для розширення або перевизначення параметрів служби без зміни основного unit-файлу використовуються конфігураційні файли з розширенням `.conf` . Такі файли застосовуються в механізмі, який називається drop-in override. Цей підхід дозволяє змінювати конфігурацію служб коректним і безпечним способом, зберігаючи цілісність основних unit-файлів, які встановлюються пакетним менеджером.

Drop-in файли зберігаються в підкаталогах:

```
/etc/systemd/system/<назва_служби>.service.d/
```

У цьому каталозі можуть розміщуватись один або кілька файлів з розширенням `.conf`, наприклад:

```
/etc/systemd/system/myservice.service.d/override.conf
```

Кожен `.conf` файл повинен мати правильну структуру systemd unit-файлів, тобто секції `[Service]`, `[Unit]` або `[Install]`, в яких указуються лише ті параметри, які потрібно змінити або додати.

Приклад вмісту `override.conf`

```
[Service]
Environment="PORT=8080"
Restart=always
```

Цей файл додасть змінну середовища до служби та змінить політику перезапуску, залишивши всі інші параметри без змін.

Для створення override-файлу використовується команда:

```
sudo systemctl edit <назва_служби>
```

Вона автоматично відкриває новий або існуючий файл `override.conf` у правильному місці. Після збереження systemd самостійно виявить і застосує ці зміни при наступному запуску служби.

Після змін обов’язково потрібно виконати:

```
sudo systemctl daemon-reload
```

щоб перечитати всі unit-файли та їхні drop-in overrides.

Варто зазначити що конфігураційні файли самих програм (які стають слюжбами) зазвичай зберігаються в окремих каталогах, які можуть бути в кількох місцях, залежно від того чи програма встановлена системно (для всіх користувачів), чи конфігурація призначена для конкретного користувача. Нижче подано основні шляхи, де зазвичай розташовані конфігураційні файли програм:

- Системні конфігурації призначені для всієї системи,  зазвичай потребують root-доступу і знаходяться в папках:

  - `/etc/<назва_програми>/`
     Наприклад:
    - `/etc/nginx/nginx.conf`
    - `/etc/ssh/sshd_config`
    - `/etc/mosquitto/mosquitto.conf`

  - Іноді: `/usr/local/etc/<назва_програми>/` (якщо програма була встановлена вручну з джерел)

- Користувацькі конфігурації (локальні для користувача) не потребують root-доступу і знаходяться в папках:

  - `~/.config/<назва_програми>/` — сучасний стандарт (XDG Base Directory Specification)

  - `~/.<назва_програми>` або `~/.<назва_програми>rc` — старіші формати

  Наприклад:

  - `~/.config/nvim/init.vim`

  - `~/.bashrc`

  - `~/.gitconfig`

  - `~/.node-red/settings.js`

Деякі програми можуть використовувати БД або спеціальні формати замість plain-text конфігів. Для `systemd` служби, конфігурація може бути частково розміщена в unit-файлі, а частково у власному каталозі програми (наприклад, Node-RED має `~/.node-red/` з `settings.js`).

### Через команду `edit`

Команда `systemctl edit` використовується для коректного зміни або доповнення конфігурації служб systemd без необхідності редагувати оригінальні unit-файли, які встановлені пакетним менеджером. Це рекомендований спосіб внесення змін, що дозволяє зберігати оновлення при модифікаціях системи та уникати конфліктів під час оновлень.

Оригінальні unit-файли служб зазвичай знаходяться в `/lib/systemd/system/` або `/usr/lib/systemd/system/` і не повинні редагуватись напряму, оскільки ці зміни можуть бути перезаписані під час оновлення відповідного пакета. Натомість `systemctl edit` створює або відкриває override-файл, який містить лише змінені параметри.

Щоб змінити службу, використовується команда:

```
sudo systemctl edit <назва_служби>
```

При виконанні цієї команди відкриється текстовий редактор (наприклад, `nano` або `vi`), у якому можна додати нові параметри або перевизначити наявні. Після збереження systemd створить файл:

```
/etc/systemd/system/<назва>.service.d/override.conf
```

Щоб, наприклад, змінити користувача, від імені якого запускається служба, потрібно додати:

```
[Service]
User=myuser
```

Якщо потрібно задати змінні середовища:

```
[Service]
Environment="DEBUG=true"
```

Щоб переглянути поточний конфігураційний override:

```
systemctl cat <назва_служби>
```

Це покаже повний ефективний unit-файл, включаючи основний та всі доповнення.

Для видалення змін, внесених через `systemctl edit`, потрібно вручну видалити override-конфігурацію:

```
sudo rm -r /etc/systemd/system/<назва>.service.d/
sudo systemctl daemon-reload
```

Після будь-яких змін необхідно виконати:

```
sudo systemctl daemon-reload
```

і перезапустити службу:

```
sudo systemctl restart <назва_служби>
```

## 4. Ведення та перегляд журналу

Systemd включає власну підсистему журналювання під назвою `systemd-journald`, яка відповідає за збір та збереження повідомлень про події від служб, ядра, користувацьких процесів та інших компонентів системи. На відміну від класичних лог-систем на базі `rsyslog`, systemd використовує бінарний журнал, який зберігається локально та може бути переглянутий за допомогою спеціального інструмента.

Підсистема журналювання systemd забезпечує централізований, ефективний та структурований спосіб ведення логів усієї системи. Інструмент `journalctl` дозволяє гнучко переглядати та фільтрувати журнали, що значно спрощує аналіз подій і діагностику проблем у службах та системі загалом.

### 4.1 Зберігання журналу

Журнали зберігаються в каталозі:

```
/var/log/journal/
```

Якщо цей каталог не існує, systemd зберігає журнали лише в оперативній пам’яті (тобто, тимчасово, до перезавантаження).

Для постійного зберігання необхідно:

```
sudo mkdir -p /var/log/journal
sudo systemd-tmpfiles --create --prefix /var/log/journal
sudo systemctl restart systemd-journald
```

#### 4.2 Перегляд журналу

Для перегляду журналу використовується команда:

```
journalctl
```

Це виведе всі доступні журнальні записи у хронологічному порядку.

Основні параметри:

- `journalctl -b` — показати журнал лише з поточного завантаження системи;
- `journalctl -u <назва_служби>` — журнал конкретної служби (наприклад, `journalctl -u ssh.service`);
- `journalctl -xe` — показати останні повідомлення з розширеним форматом;
- `journalctl -f` — режим реального часу (аналог `tail -f`);
- `journalctl --since "2025-08-01"` — вивести повідомлення з вказаної дати;
- `journalctl --no-pager` — вивести журнал без посторінкового виводу.

#### 4.3 Користувацькі журнали

Для доступу до логів від імені звичайного користувача, користувач має бути у групі `systemd-journal`:

```
sudo usermod -aG systemd-journal <ім’я_користувача>
```

Після цього потрібно перелогінитися.

#### 4.4 Ротація та обмеження журналів

Файл `/etc/systemd/journald.conf` містить параметри, які визначають:

- максимальний розмір журналу (`SystemMaxUse`);
- максимальний розмір одного файлу (`SystemMaxFileSize`);
- час зберігання (`MaxRetentionSec`).

Зміни в цьому файлі набирають чинності після перезапуску служби:

```
sudo systemctl restart systemd-journald
```



Теоретичне заняття розробив [Прізвище або нік розробника Імя](https://github.com). 
